# 从原型到生产
*November 2025*

## 致谢

### 内容贡献者
- Derek Egan
- Chase Lyall
- Anant Nawalgaria
- Lavi Nigam
- Kanchana Patlolla
- Michael Vakoc

### 策展人和编辑
- Anant Nawalgaria
- Kanchana Patlolla

### 设计师
- Michael Lanning

---

## 目录

### 摘要 5
### 简介：从原型到生产 6
### 人员与流程 8
### 通往生产的旅程 11
#### 评估作为质量门槛 12
#### 自动化 CI/CD 流水线 13
#### 安全发布策略 15
#### 从一开始构建安全 17
### 生产中的运维 19
#### 观察：您的代理的感官系统 19
#### 行动：运维控制的杠杆 20
#### 管理系统健康：性能、成本和规模 20
#### 管理风险：安全响应手册 22
#### 演进：从生产中学习 22
##### 演进的引擎：自动化的生产路径 23
##### 演进工作流：从洞察到部署改进 24
##### 演进安全：生产反馈循环 25
### 超越单代理运维 26
#### A2A - 可重用性和标准化 27
#### A2A 协议：从概念到实现 28
#### A2A 和 MCP 如何协同工作 33
#### 注册表架构：何时以及如何构建它们 35
### 整合一切：AgentOps 生命周期 36
### 结论：用 AgentOps 弥合最后一英里 38
### 注释 40

---

## 摘要

本白皮书提供了 AI 代理运营生命周期的综合技术指南，重点关注部署、扩展和生产化。在 Day 4 对评估和可观察性的覆盖基础上，本指南强调如何通过强大的 CI/CD 流水线和可扩展的基础设施来建立必要的信任，以将代理投入生产。它探讨了将基于代理的系统从原型过渡到企业级解决方案的挑战，特别关注 Agent2Agent (A2A) 互操作性。本指南为 AI/ML 工程师、DevOps 专业人员和系统架构师提供了实用见解。

**构建一个代理很容易。相信它很难。**

---

这带来了独特的运营挑战，需要专门的策略：

- **动态工具编排**：代理的"轨迹"是实时组装的，因为它会挑选和选择工具。这需要为每次行为都不同的系统提供强大的版本控制、访问控制和可观察性。

- **可扩展的状态管理**：代理可以在交互之间记住事情。在大规模下安全且一致地管理会话和记忆是一个复杂的系统设计问题。

- **不可预测的成本和延迟**：代理可以采取许多不同的路径来找到答案，使得其成本和响应时间极其难以预测和控制，需要智能的预算和缓存策略。

为了成功应对这些挑战，您需要建立在三个关键支柱之上的基础：自动化评估、自动化部署（CI/CD）和全面的可观察性。

本白皮书是您构建该基础并导航生产路径的分步指南！我们将从生产前的基本要素开始，向您展示如何设置自动化 CI/CD 流水线并使用严格的评估作为关键质量检查。从那里，我们将深入探讨在野外运行代理的挑战，涵盖扩展、性能调优和实时监控的策略。最后，我们将展望多代理系统的激动人心世界，通过代理到代理协议，探索使它们安全有效通信需要什么。

---

## 人员和流程

在所有关于 CI/CD、可观察性和动态流水线的讨论之后，为什么还要关注人员和流程？因为世界上最好的技术如果没有合适的团队来构建、管理和治理，也是无效的。

那个客户服务代理并不是神奇地被阻止赠送免费产品；AI 工程师和提示工程师设计并实现了防护栏。机密数据库不是由抽象概念保护的；云平台团队配置了身份验证。在每个成功的生产级代理背后，都有一个精心协调的专家团队，在本节中，我们将介绍关键参与者。

### 实施指南

在整个白皮书中，实际示例参考了 Google Cloud Platform Agent Starter Pack¹——这是一个 Python 包，为 Google Cloud 提供生产就绪的生成式 AI 代理模板。它包括预构建的代理、自动化 CI/CD 设置、Terraform 部署、Vertex AI 评估集成和内置的 Google Cloud 可观察性。入门包通过您可以在几分钟内部署的工作代码演示了这里讨论的概念。

![图 1：显示"运维"是人员、流程和技术交集的图表](#)

**图 1**：显示"运维"是人员、流程和技术交集的图表

在传统的 MLOps 环境中，这涉及几个关键团队：

- **云平台团队**：包括云架构师、管理员和安全专家，该团队管理基础云基础设施、安全和访问控制。该团队授予工程师和服务账户最小特权角色，确保仅访问必要资源。

- **数据工程团队**：数据工程师和数据所有者构建和维护数据流水线，处理摄取、准备和质量标准。

- **数据科学和 MLOps 团队**：这包括实验和训练模型的数据科学家，以及使用 CI/CD 在大规模上自动化端到端 ML 流水线（例如，预处理、训练、后处理）的 ML 工程师。MLOps 工程师通过构建和维护标准化流水线基础设施来支持这一点。

- **机器学习治理**：这个集中化功能，包括产品所有者和审计员，监督 ML 生命周期，作为工件和指标的存储库，以确保合规性、透明度和问责制。

生成式 AI 为这个环境引入了新的复杂性层次和专门角色：

- **提示工程师**：虽然这个角色头衔在行业中仍在发展，但这些个人将制作提示的技术技能与深厚的领域专业知识相结合。他们定义从模型中提出的正确问题和预期答案，尽管在实践中，根据组织的成熟度，这项工作可能由 AI 工程师、领域专家或专门专家完成。

- **AI 工程师**：他们负责将 GenAI 解决方案扩展到生产，构建包含大规模评估、防护栏和 RAG/工具集成的强大后端系统。

- **DevOps/应用程序开发人员**：这些开发人员构建与 GenAI 后端集成的前端组件和用户友好的界面。

组织的规模和结构将影响这些角色；在较小的公司中，个人可能担任多个角色，而成熟的组织将有更专业的团队。有效协调所有这些不同角色对于建立强大的运营基础并成功将传统 ML 和生成式 AI 计划投入生产至关重要。

---

## 通往生产的旅程

### 评估作为质量门槛

为什么我们需要为代理设置特殊的质量门槛？传统的软件测试对于推理和适应的系统来说是不够的。此外，评估代理与评估 LLM 是不同的；它需要评估的不仅仅是最终答案，还有完成任务的整个推理和行动轨迹。一个代理可以通过其工具的 100 个单元测试，但仍然可能通过选择错误的工具或产生幻觉响应而惨败。我们需要评估其行为质量，而不仅仅是其功能正确性。这个门槛可以通过两种主要方式实现：

1. **手动"预 PR"评估**：对于寻求灵活性或刚刚开始评估旅程的团队，质量门槛通过团队流程强制执行。在提交拉取请求（PR）之前，AI 工程师或提示工程师（或在您组织中负责代理行为的任何人）在本地运行评估套件。然后将结果性能报告——比较新代理与生产基线——链接在 PR 描述中。这使得评估结果成为人工审查的强制性工件。审查者——通常是另一个 AI 工程师或机器学习治理者——现在负责评估不仅代码，还有代理的行为变化，针对防护栏违规和提示注入漏洞。

2. **自动化流水线内门槛**：对于成熟的团队，由数据科学和 MLOps 团队构建和维护的评估工具直接集成到 CI/CD 流水线中。失败的评估会自动阻止部署，提供机器学习治理团队定义的质量标准的严格、程序化执行。这种方法以手动审查的灵活性换取自动化的一致性。CI/CD 流水线可以配置为自动触发评估作业，将新代理的响应与黄金数据集进行比较。如果关键指标，如"工具调用成功率"或"有用性"，低于预定义阈值，部署将被程序化阻止。

无论采用何种方法，原则都是相同的：没有代理不经过质量检查就进入生产。我们在 Day 4 的深度探讨中介绍了要测量什么以及如何构建这个评估工具：代理质量：可观察性、日志记录、追踪、评估、指标，其中探讨了从制作"黄金数据集"（策划的、代表性的测试用例集，旨在评估代理的预期行为和防护栏合规性）到实施 LLM 作为评判技术，最后使用像 Vertex AI Evaluation² 这样的服务来驱动评估的一切。

### 自动化 CI/CD 流水线

AI 代理是一个复合系统，不仅包括源代码，还包括提示、工具定义和配置文件。这种复杂性带来了重大挑战：我们如何确保对提示的更改不会降低工具的性能？我们如何在它们到达用户之前测试所有这些工件之间的相互作用？

解决方案是 CI/CD（持续集成/持续部署）流水线。它不仅仅是一个自动化脚本；它是一个结构化流程，帮助团队中的不同人员协作管理复杂性并确保质量。它通过分阶段测试更改来工作，在代理发布给用户之前逐步建立信心。

强大的流水线被设计为漏斗。它尽可能早且便宜地捕获错误，这种实践通常被称为"左移"。它将快速的预合并检查与更全面、资源密集型的合并后部署分开。这个渐进式工作流通常构建为三个不同的阶段：

1. **阶段 1：预合并集成（CI）**：流水线的首要责任是为已打开拉取请求的 AI 工程师或提示工程师提供快速反馈。自动触发后，这个 CI 阶段充当主分支的守门员。它运行快速检查，如单元测试、代码检查和依赖扫描。至关重要的是，这是运行提示工程师设计的代理质量评估套件的理想阶段。这在合并之前提供了关于更改是否改善或降低代理在关键场景下性能的即时反馈。通过在这里捕获问题，我们防止污染主分支。使用 Agent Starter Pack¹ (ASP) 生成的 PR 检查配置模板³ 是使用 Cloud Build⁴ 实施此阶段的实际示例。

2. **阶段 2：预发布环境中的合并后验证（CD）**：一旦更改通过了所有 CI 检查——包括性能评估——并被合并，焦点就从代码和性能正确性转向集成系统的运营就绪性。持续部署（CD）过程，通常由 MLOps 团队管理，打包代理并将其部署到预发布环境——生产环境的高保真副本。在这里运行更全面、资源密集型的测试，如负载测试和针对远程服务的集成测试。这也是内部用户测试（通常称为"dogfooding"）的关键阶段，公司内部的人员可以在代理到达最终用户之前与代理交互并提供定性反馈。这确保代理作为集成系统在考虑发布之前在生产类似条件下可靠且高效地执行。来自 ASP 的预发布部署模板⁵ 显示了此部署的示例。

3. **阶段 3：门控的生产部署**：代理在预发布环境中经过彻底验证后，最后一步是部署到生产环境。这几乎从不是完全自动的，通常需要产品所有者给出最终批准，确保人在回路中。批准后，在预发布环境中测试和验证的确切部署工件被提升到生产环境。使用 ASP 生成的生产部署模板⁶ 显示了这个最后阶段如何检索验证的工件并将其部署到生产环境并配备适当的保障措施。

![图 3：CI/CD 过程的不同阶段](#)

**图 3**：CI/CD 过程的不同阶段

实现这个三阶段 CI/CD 工作流需要强大的自动化基础设施和适当的密钥管理。这种自动化由两个关键技术驱动：

- **基础设施即代码（IaC）**：像 Terraform 这样的工具以编程方式定义环境，确保它们相同、可重复和版本控制。例如，使用 Agent Starter Pack⁷ 生成的这个模板提供了完整代理基础设施的 Terraform 配置，包括 Vertex AI、Cloud Run 和 BigQuery 资源。

- **自动化测试框架**：像 Pytest 这样的框架在每个阶段执行测试和评估，处理代理特定的工件，如对话历史、工具调用日志和动态推理轨迹。

此外，敏感信息（如工具的 API 密钥）应使用像 Secret Manager⁸ 这样的服务安全管理，并在运行时注入代理的环境中，而不是硬编码在存储库中。

### 安全发布策略

虽然全面的生产前检查至关重要，但实际应用不可避免地会揭示意想不到的问题。与其一次性切换 100% 的用户，不如考虑通过谨慎监控的渐进式发布来最小化风险。

### 从一开始构建安全

安全的发布策略保护您免受错误和中断的影响，但代理面临独特的挑战：它们可以自主推理和行动。如果代理没有用适当的安全和责任措施构建，即使完美部署的代理也可能造成伤害。这需要一个从第一天就嵌入的综合治理策略，而不是事后添加。

与遵循预定路径的传统软件不同，代理会做决策。它们解释模糊的请求，访问多个工具，并在会话之间保持记忆。这种自主性创造了独特的风险：

- **提示注入和恶意行为**：恶意用户可以欺骗代理执行意外操作或绕过限制。
- **数据泄露**：代理可能通过其响应或工具使用无意中暴露敏感信息。
- **记忆中毒**：存储在代理记忆中的虚假信息可能腐蚀所有未来的交互。

幸运的是，像 Google 的安全代理方法¹² 和 Google 安全 AI 框架 (SAIF)¹³ 这样的框架通过三层防御来解决这些挑战：

1. **策略定义和系统指令（代理的宪法）**：过程首先定义期望和不期望代理行为的策略。这些被工程化为系统指令 (SI)，作为代理的核心宪法。

2. **防护栏、保障措施和过滤（执行层）**：这一层充当硬停止执行机制。
   - **输入过滤**：使用分类器和像 Perspective API 这样的服务来分析提示并在它们到达代理之前阻止恶意输入。
   - **输出过滤**：在代理生成响应后，Vertex AI 的内置安全过滤器提供对有害内容、PII 或策略违规的最终检查。例如，在响应发送给用户之前，它通过 Vertex AI 的内置安全过滤器¹⁴，可以配置为阻止包含特定 PII、有毒语言或其他有害内容的输出。
   - **人在回路 (HITL) 升级**：对于高风险或模糊的操作，系统必须暂停并升级给人类进行审查和批准。

3. **持续保证和测试**：安全不是一次性设置。它需要持续的评估和适应。
   - **严格的评估**：对模型或其安全系统的任何更改都必须触发使用 Vertex AI Evaluation 的全面评估流水线的完全重新运行。
   - **专门的 RAI 测试**：通过创建专门的数据集或使用模拟代理来严格测试特定风险，包括中立观点 (NPOV) 评估和平等评估。
   - **主动红队测试**：通过创造性的手动测试和 AI 驱动的基于角色的模拟来积极尝试破坏安全系统。

---

## 生产中的运维

您的代理已上线。现在焦点从开发转向一个根本不同的挑战：在与数千用户交互时保持系统的可靠性、成本效益和安全性。传统服务在可预测的逻辑上运行。相比之下，代理是一个自主行动者。它遵循意外推理路径的能力意味着它可以在没有直接监督的情况下表现出紧急行为并累积成本。

管理这种自主性需要不同的运营模型。不是静态监控，有效的团队采用持续循环：实时观察系统行为，行动以保持性能和安全，并基于生产学习演进代理。这个集成循环是在生产中成功运营代理的核心学科。

### 观察：您代理的感官系统

要信任和管理自主代理，您必须首先了解其过程。可观察性提供了这种关键洞察，作为后续"行动"和"演进"阶段的感官系统。强大的可观察性实践建立在三个支柱之上，它们协同工作以提供代理行为的完整图景：

- **日志**：发生了什么的细粒度、事实日记，记录每个工具调用、错误和决策。
- **追踪**：连接单个日志的叙述，揭示代理采取特定行动的因果路径。
- **指标**：聚合报告卡，总结性能、成本和大规模运营健康状况，以显示系统运行得如何。

例如，在 Google Cloud 中，这是通过操作套件实现的：用户的请求在 Cloud Trace¹⁵ 中生成唯一 ID，将 Vertex AI Agent Engine⁹ 调用、模型调用和工具执行与可见持续时间链接起来。详细日志流向 Cloud Logging¹⁶，而 Cloud Monitoring¹⁷ 仪表板在延迟阈值超过时发出警报。代理开发工具包 (ADK)¹⁸ 提供内置的 Cloud Trace 集成，用于代理操作的自动检测。

通过实现这些支柱，我们从黑暗操作转向对代理行为的清晰、数据驱动视图，为在生产中有效管理它提供了所需基础。（有关这些概念的完整讨论，请参见代理质量：可观察性、日志记录、追踪、评估、指标）。

### 行动：运维控制的杠杆

没有行动的观察只是昂贵的仪表板。"行动"阶段是关于实时干预——您基于观察拉动的管理代理性能、成本和安全的杠杆。

将"行动"视为为维持实时稳定性而设计的系统自动反射。相比之下，稍后将涵盖的"演进"是从行为中学习以创建根本上更好系统的战略过程。

因为代理是自主的，您不能预先编程每个可能的结果。相反，您必须构建强大的机制来影响其在生产中的行为。这些运营杠杆分为两个主要类别：管理系统健康和管理其风险。

#### 管理系统健康：性能、成本和规模

与传统的微服务不同，代理的工作负载是动态和有状态的。管理其健康需要处理这种不可预测性的策略。

#### 管理风险：安全响应手册

因为代理可以自行行动，您需要一个快速遏制的手册。当检测到威胁时，响应应遵循清晰的顺序：遏制、分诊和解决。

第一步是立即遏制。优先级是停止伤害，通常使用"熔断器"——一个功能标志来立即禁用受影响的工具。

接下来是分诊。威胁被遏制后，可疑请求被路由到人在回路 (HITL) 审查队列以调查漏洞的范围和影响。

最后，焦点转向永久解决方案。团队开发一个补丁——如更新的输入过滤器或系统提示——并通过自动化 CI/CD 流水线部署，确保在永久阻止漏洞之前完全测试修复。

### 演进：从生产中学习

虽然"行动"阶段提供系统的即时、战术反射，但"演进"阶段是关于长期、战略改进。它开始时查看在您的可观察性数据中收集的模式和趋势，并询问一个关键问题："我们如何修复根本原因，使这个问题永远不会再次发生？"

这是您从响应生产事件转向主动使您的代理更智能、更高效和更安全的地方。您将"观察"阶段的原始数据转化为代理架构、逻辑和行为中的持久改进。

#### 演进的引擎：自动化的生产路径

来自生产的洞察只有在您能快速对其采取行动时才有价值。如果您团队需要六个月时间来部署修复，观察到 30% 的用户在特定任务上失败是无用的。

这就是您在生产前（第3节）构建的自动化 CI/CD 流水线成为运营循环最关键组件的地方。它是驱动快速演进的引擎。快速、可靠的生产路径允许您在几小时或几天内而不是几周或几个月内关闭观察和改进之间的循环。

当您识别出潜在改进时——无论是精炼的提示、新工具还是更新的安全防护栏——过程应该是：

1. **提交更改**：提议的改进被提交到您的版本控制存储库。
2. **触发自动化**：提交自动触发您的 CI/CD 流水线。
3. **严格验证**：流水线运行完整的单元测试套件、安全扫描和针对您更新数据集的代理质量评估套件。
4. **安全部署**：一旦验证，更改使用安全发布策略部署到生产环境。

这个自动化工作流将演进从缓慢、高风险的手动项目转变为快速、可重复和数据驱动的过程。

#### 演进工作流：从洞察到部署改进

1. **分析生产数据**：从生产日志中识别用户行为、任务成功率和安全事件的趋势。
2. **更新评估数据集**：将生产故障转化为明天的测试用例，增强您的黄金数据集。
3. **精炼和部署**：提交改进以触发自动化流水线——无论是精炼提示、添加工具还是更新防护栏。

这创建了一个良性循环，您的代理通过每次用户交互持续改进。

**演进循环实战**

零售代理的日志（观察）显示 15% 的用户在询问"相似产品"时收到错误。产品团队通过创建高优先级工单来行动。演进阶段开始：生产日志被用来为评估数据集创建新的、失败的测试用例。AI 工程师精炼代理的提示并添加一个新的、更强大的相似性搜索工具。更改被提交，在 CI/CD 流水线中通过现在更新的评估套件，并通过金丝雀部署安全推出，在 48 小时内解决用户问题。

#### 演进安全：生产反馈循环

虽然基础安全和责任框架在生产前（第3.4节）建立，但工作从未真正完成。安全不是静态检查清单；它是一个动态、持续的适应过程。生产环境是最终的测试场，在那里收集的洞察对于针对真实世界威胁加固您的代理至关重要。

这就是观察→行动→演进循环对安全变得关键的地方。这个过程是演进工作流的直接扩展：

1. **观察**：您的监控和日志记录系统检测到新的威胁向量。这可能是一种绕过您当前过滤器的新颖提示注入技术，或导致轻微数据泄露的意外交互。

2. **行动**：立即安全响应团队遏制威胁（如第4.2节所讨论）。

3. **演进**：这是长期韧性的关键步骤。安全洞察被反馈回您的开发生命周期：
   - **更新评估数据集**：新的提示注入攻击被作为永久测试用例添加到您的评估套件中。
   - **精炼防护栏**：提示工程师或 AI 工程师精炼代理的系统提示、输入过滤器或工具使用策略以阻止新的攻击向量。
   - **自动化和部署**：工程师提交更改，这触发完整的 CI/CD 流水线。更新的代理针对新扩展的评估集进行严格验证并部署到生产环境，关闭漏洞。

---

## 超越单代理运维

### A2A - 可重用性和标准化

您在组织中构建了数十个专门的代理。客户服务团队有他们的支持代理。分析构建了预测系统。风险管理创建了欺诈检测。但问题是：这些代理不能相互通信——无论是因为它们是在不同框架、项目或完全不同的云中创建的。

这种隔离造成了巨大的低效率。每个团队重新构建相同的能力。关键洞察被困在孤岛中。您需要的是互操作性——任何代理能够利用任何其他代理的能力的能力，无论谁构建了它或他们使用了什么框架。

为了解决这个问题，需要一种原则性的标准化方法，建立在两个不同但互补的协议之上。虽然我们在《代理工具与 MCP 互操作性》中详细介绍的模型上下文协议 (MCP²²) 为工具集成提供了通用标准，但对于智能代理之间所需的复杂、有状态协作来说，它是不够的。这就是现在由 Linux 基金会管理的 Agent2Agent (A2A²³) 协议旨在解决的问题。

这种区别至关重要。当您需要一个简单的、无状态的函数，如获取天气数据或查询数据库时，您需要一个说 MCP 的工具。但当您需要委托一个复杂目标时，如"分析上季度客户流失并推荐三种干预策略"，您需要一个能够通过 A2A 自主推理、计划和行动的智能伙伴。简而言之，MCP 让您说"做这个特定的事情"，而 A2A 让您说"实现这个复杂目标"。

### A2A 协议：从概念到实现

A2A 协议旨在打破组织孤岛并实现代理之间的无缝协作。考虑一个场景，欺诈检测代理发现可疑活动。为了理解完整上下文，它需要来自独立交易分析代理的数据。没有 A2A，人工分析师必须手动弥合这个差距——这个过程可能需要几小时。有了 A2A，代理自动协作，在几分钟内解决问题。

协作的第一步是发现委托给正确的代理——这通过代理卡²⁴实现，它是标准化的 JSON 规范，充当每个代理的名片。代理卡描述代理能做什么、其安全要求、其技能以及如何联系它（url），允许生态系统中的任何其他代理动态发现其同伴。请参见下面的代理卡示例：

```python
# 代码片段 1：check_prime_agent 的示例代理卡
{
  "name": "check_prime_agent",
  "version": "1.0.0",
  "description": "专门检查数字是否为质数的代理",
  "capabilities": {},
  "securitySchemes": {
     "agent_oauth_2_0": {
        "type": "oauth2",
  }
  "defaultInputModes": ["text/plain"],
  "defaultOutputModes": ["application/json"],
  "skills": [
    {
      "id": "prime_checking",
      "name": "质数检查",
      "description": "使用高效算法检查数字是否为质数",
      "tags": ["mathematical", "computation", "prime"]
    }
  ],
  "url": "http://localhost:8001/a2a/check_prime_agent"
}
```

采用此协议不需要架构大修。像 ADK 这样的框架显著简化了这个过程（文档²⁵）。您可以通过单个函数调用使现有代理与 A2A 兼容，这会自动生成其 AgentCard 并使其在网络上可用。

```python
# 代码片段 2：使用 ADK 的 to_a2a 实用程序包装现有代理并暴露它进行 A2A 通信
# 使用 ADK 的示例：通过 A2A 暴露代理
from google.adk.a2a.utils.agent_to_a2a import to_a2a

# 您现有的代理
root_agent = Agent(
    name='hello_world_agent',
    # ... 您的代理代码 ...
)

# 使其与 A2A 兼容
a2a_app = to_a2a(root_agent, port=8001)

# 使用 uvicorn 提供服务
# uvicorn agent:a2a_app --host localhost --port 8001

# 或使用 Agent Engine 提供服务
# from vertexai.preview.reasoning_engines import A2aAgent
# from google.adk.a2a.executor.a2a_agent_executor import A2aAgentExecutor
# a2a_agent = A2aAgent(
#    agent_executor_builder=lambda: A2aAgentExecutor(agent=root_agent)
# )
```

一旦代理被暴露，任何其他代理都可以通过引用其 AgentCard 来使用它。例如，客户服务代理现在可以查询远程产品目录代理，而无需了解其内部工作原理。

```python
# 代码片段 4：在 ADK 中使用远程 A2A 代理 (prime_agent) 作为分层代理结构中的子代理
# 使用 ADK 的示例：分层代理组合
# 用于掷骰子的 ADK 本地子代理
roll_agent = Agent(
    name="roll_agent",
    instruction="您是掷骰子专家。"
)

# 用于质数检查的 ADK 远程 A2A 代理
prime_agent = RemoteA2aAgent(
    name="prime_agent",
    agent_card="http://localhost:8001/.well-known/agent-card.json"
)

# 结合两者的 ADK 根编排器
root_agent = Agent(
    name="root_agent",
    instruction="""委托掷骰子给 roll_agent，质数检查给 prime_agent。""",
    sub_agents=[roll_agent, prime_agent]
)
```

然而，启用这种级别的自主协作引入了两个不可协商的技术要求。首先是分布式追踪，其中每个请求携带唯一的追踪 ID，这对于调试和维护跨多个代理的连贯审计轨迹至关重要。其次是强大的状态管理。A2A 交互本质上是有状态的，需要复杂的持久层来跟踪进度并确保事务完整性。

A2A 最适合需要持久服务合同的正式、跨团队集成。对于单个应用程序中的紧密耦合任务，轻量级本地子代理通常仍然是更高效的选择。随着生态系统的成熟，新代理应该构建为对两种协议的原生支持，确保每个新组件立即可发现、可互操作和可重用，复合整个系统的价值。

#### A2A 和 MCP 如何协同工作

![图 4：A2A 和 MCP 协作一览](#)

**图 4**：A2A 和 MCP 协作一览

A2A 和 MCP 不是竞争标准；它们是设计为在不同抽象级别操作的互补协议。区别取决于代理与什么交互。MCP 是工具和资源的领域——具有明确定义、结构化输入和输出的原语，如计算器或数据库 API。A2A 是其他代理的领域——能够推理、计划、使用多个工具并维护状态以实现复杂目标的自主系统。

最强大的代理系统在分层架构中使用两种协议。应用程序可能主要使用 A2A 来编排多个智能代理之间的高级协作，而每个代理内部使用 MCP 与其自己特定的工具和资源集交互。

一个实际的类比是由自主 AI 代理工作人员的汽车修理店。

1. **用户到代理 (A2A)**：客户使用 A2A 与"商店经理"代理通信来描述高级问题："我的车发出嘎嘎声。"
2. **代理到代理 (A2A)**：商店经理进行多轮诊断对话，然后使用 A2A 将任务委托给专门的"机械师"代理。
3. **代理到工具 (MCP)**：机械师代理现在需要执行特定操作。它使用 MCP 调用其专门工具：它在诊断扫描仪上运行 scan_vehicle_for_error_codes()，使用 get_repair_procedure() 查询维修手册数据库，并使用 raise_platform() 操作平台升降机。
4. **代理到代理 (A2A)**：诊断问题后，机械师代理确定需要零件。它使用 A2A 与外部"零件供应商"代理通信以询问可用性并下订单。

在这个工作流中，A2A 促进客户、商店代理和外部供应商之间更高级别、对话式和任务导向的交互。同时，MCP 提供标准化管道，使机械师代理能够可靠地使用其特定的、结构化工具来完成工作。

#### 注册表架构：何时以及如何构建它们

为什么一些组织构建注册表而其他组织不需要？答案在于规模和复杂性。当您有五十个工具时，手动配置工作正常。但当您达到分布在团队和环境中的五千个工具时，您面临一个需要系统解决方案的发现问题。

工具注册表使用像 MCP 这样的协议来编目所有资产，从函数到 API。您不给代理访问数千个工具，而是创建精选列表，导致三种常见模式：

- **通才代理**：访问完整目录，以速度和准确性换取范围。
- **专家代理**：使用预定义子集以获得更高性能。
- **动态代理**：在运行时查询注册表以适应新工具。

主要好处是人类发现——开发人员可以在构建重复工具之前搜索现有工具，安全团队可以审计工具访问，产品所有者可以了解他们代理的能力。

---

### 整合一切：AgentOps 生命周期

要获得 AI 代理运营化的全面演练，包括评估、工具管理、CI/CD 标准化和有效架构设计，请在官方 Google Cloud YouTube 频道上观看《AgentOps: Operationalize AI Agents》视频²⁶。

![图 5：AgentOps 核心能力、环境和流程](#)

**图 5**：AgentOps 核心能力、环境和流程

### 结论：用 AgentOps 弥合最后一英里

将 AI 原型转移到生产系统是一个组织转型，需要新的运营纪律：AgentOps。

大多数代理项目在"最后一英里"失败，不是由于技术，而是因为自主系统的运营复杂性被低估了。本指南绘制了弥合这一差距的路径。它首先建立人员和流程作为治理的基础。接下来，基于评估门槛部署的生产前策略自动化高风险发布。一旦上线，持续的观察→行动→演进循环将每次用户交互转化为潜在洞察。最后，互操作性协议通过将孤立代理转变为协作、智能生态系统来扩展系统。

即时好处——如防止安全漏洞或启用快速回滚——证明了投资的合理性。但真正价值是速度。成熟的 AgentOps 实践允许团队在几小时而不是几周内部署改进，将静态部署转变为持续演进的产品。

#### 您的前进道路

- **如果您刚开始**，专注于基础：构建您的第一个评估数据集，实施 CI/CD 流水线，并建立全面监控。代理入门包是一个很好的起点——它在几分钟内创建一个生产就绪的代理项目，这些基础已经内置。

- **如果您在扩展**，提升您的实践：自动化从生产洞察到部署改进的反馈循环，并在互操作性协议上标准化以构建内聚生态系统，而不仅仅是点解决方案。

下一个前沿不仅是构建更好的单个代理，而是编排学习协作的复杂多代理系统。AgentOps 的运营纪律是使这成为可能的基础。

我们希望这本剧本赋予您构建下一代智能、可靠和值得信赖的 AI 的能力。因此，弥合最后一英里不是项目的最后一步，而是创造价值的第一步！

---

## 注释

1. https://github.com/GoogleCloudPlatform/agent-starter-pack
2. https://cloud.google.com/vertex-ai/docs/evaluation/introduction
3. https://github.com/GoogleCloudPlatform/agent-starter-pack/blob/example-agent/example-agent/.cloudbuild/pr_checks.yaml
4. https://cloud.google.com/build
5. https://github.com/GoogleCloudPlatform/agent-starter-pack/blob/example-agent/example-agent/.cloudbuild/staging.yaml
6. https://github.com/GoogleCloudPlatform/agent-starter-pack/blob/example-agent/example-agent/.cloudbuild/deploy-to-prod.yaml
7. https://github.com/GoogleCloudPlatform/agent-starter-pack/blob/example-agent/example-agent/terraform
8. https://cloud.google.com/secret-manager
9. https://cloud.google.com/agent-builder/agent-engine/overview
10. https://cloud.google.com/run
11. https://cloud.google.com/load-balancing/docs/https/traffic-management
12. https://research.google/pubs/an-introduction-to-googles-approach-for-secure-ai-agents/
13. https://safety.google/cybersecurity-advancements/saif/
14. https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/configure-safety-attributes
15. https://cloud.google.com/trace
16. https://cloud.google.com/logging
17. https://cloud.google.com/monitoring
18. https://google.github.io/adk-docs/observability/cloud-trace/
19. https://cloud.google.com/pubsub
20. https://cloud.google.com/alloydb
21. https://cloud.google.com/sql
22. https://modelcontextprotocol.io/
23. https://a2a-protocol.org/latest/specification/
24. https://a2a-protocol.org/latest/specification/#5-agent-discovery-the-agent-card
25. https://google.github.io/adk-docs/a2a/
26. https://www.youtube.com/watch?v=kJRgj58ujEk